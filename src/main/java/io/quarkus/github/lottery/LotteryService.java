package io.quarkus.github.lottery;

import java.io.IOException;
import java.time.Clock;
import java.time.Instant;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import io.quarkus.github.lottery.config.DeploymentConfig;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import io.quarkus.github.lottery.config.LotteryConfig;
import io.quarkus.github.lottery.draw.DrawRef;
import io.quarkus.github.lottery.draw.Lottery;
import io.quarkus.github.lottery.draw.LotteryReport;
import io.quarkus.github.lottery.draw.Participant;
import io.quarkus.github.lottery.github.GitHubRepository;
import io.quarkus.github.lottery.github.GitHubRepositoryRef;
import io.quarkus.github.lottery.github.GitHubService;
import io.quarkus.github.lottery.history.HistoryService;
import io.quarkus.github.lottery.history.LotteryHistory;
import io.quarkus.github.lottery.notification.NotificationService;
import io.quarkus.github.lottery.notification.Notifier;
import io.quarkus.logging.Log;
import io.quarkus.scheduler.Scheduled;

@ApplicationScoped
public class LotteryService {

    @Inject
    DeploymentConfig deploymentConfig;

    @Inject
    GitHubService gitHubService;

    @Inject
    HistoryService historyService;

    @Inject
    NotificationService notificationService;

    @Inject
    Clock clock;

    /**
     * Draws the lottery and sends lists of tickets to participants as necessary.
     */
    @Scheduled(every = "1H", concurrentExecution = Scheduled.ConcurrentExecution.SKIP) // Every hour
    public synchronized void draw() throws IOException {
        Log.info("Starting draw...");
        List<GitHubRepositoryRef> refs = gitHubService.listRepositories();
        Log.infof("Will draw for the following repositories: %s", refs);

        // TODO parallelize
        for (GitHubRepositoryRef ref : refs) {
            Log.infof("Starting draw for repository %s...", ref);
            try {
                drawForRepository(ref);
                Log.infof("End of draw for repository %s.", ref);
            } catch (Exception e) {
                Log.errorf(e, "Error drawing for repository %s", ref);
            }
        }
        Log.info("End of draw.");
    }

    private void drawForRepository(GitHubRepositoryRef repoRef) throws IOException {
        try (GitHubRepository repo = gitHubService.repository(repoRef)) {
            var optionalLotteryConfig = repo.fetchLotteryConfig();
            if (optionalLotteryConfig.isEmpty()) {
                Log.infof("No lottery configuration found for %s; not drawing lottery.", repoRef);
                return;
            }
            doDrawForRepository(repo, optionalLotteryConfig.get());
        }
    }

    private void doDrawForRepository(GitHubRepository repo, LotteryConfig lotteryConfig) throws IOException {
        var now = Instant.now(clock);
        var drawRef = new DrawRef(repo.ref(), now);

        // Note: this map only gives partial information -- some maintainers may not be registered for the lottery.
        // That's why the information is only used for optimization (to skip issues that we know for sure aren't relevant).
        var maintainerUsernamesByAreaLabel = new HashMap<String, Set<String>>();
        for (LotteryConfig.Participant participant : lotteryConfig.participants()) {
            participant.maintenance().ifPresent(m -> {
                for (String label : m.labels()) {
                    maintainerUsernamesByAreaLabel.computeIfAbsent(label, key -> new LinkedHashSet<>())
                            .add(participant.username());
                }
            });
        }

        Lottery lottery = new Lottery(now, deploymentConfig, lotteryConfig.buckets(), maintainerUsernamesByAreaLabel);

        try (var notifier = notificationService.notifier(drawRef, lotteryConfig.notifications())) {
            var history = historyService.fetch(drawRef, lotteryConfig);
            List<Participant> participants = registerParticipants(drawRef, lottery, notifier, history,
                    lotteryConfig.participants());

            lottery.draw(repo, history);

            var sent = notifyParticipants(lotteryConfig, notifier, participants);
            if (!sent.isEmpty()) {
                try {
                    historyService.append(drawRef, lotteryConfig, sent);
                } catch (IOException | RuntimeException e) {
                    Log.errorf(e, "Failed to save the following lottery report to history: %s", sent);
                }
            }
        }
    }

    private List<Participant> registerParticipants(DrawRef drawRef, Lottery lottery, Notifier notifier,
            LotteryHistory history, List<LotteryConfig.Participant> participantConfigs) throws IOException {
        List<Participant> participants = new ArrayList<>();

        // Add participants to the lottery as necessary.
        for (LotteryConfig.Participant participantConfig : participantConfigs) {
            String username = participantConfig.username();
            ZoneId timezone = participantConfig.timezone().orElse(ZoneOffset.UTC);

            Optional<ZonedDateTime> lastNotificationToday = history.lastNotificationToday(username, timezone);
            if (lastNotificationToday.isPresent()) {
                Log.debugf("Skipping user %s who has already been notified today (on %s)",
                        username, lastNotificationToday.get());
                continue;
            }

            if (notifier.isIgnoring(username)) {
                Log.debugf("Skipping user %s whose dedicated issue is closed", username);
                continue;
            }

            Participant.create(drawRef, participantConfig).ifPresent(p -> {
                participants.add(p);
                p.participate(lottery);
            });
        }

        return participants;
    }

    private List<LotteryReport.Serialized> notifyParticipants(LotteryConfig lotteryConfig,
            Notifier notifier, List<Participant> participants) {
        List<LotteryReport.Serialized> sent = new ArrayList<>();
        for (var participant : participants) {
            var report = participant.report(lotteryConfig.buckets().triage().label(),
                    new LinkedHashSet<>(lotteryConfig.buckets().maintenance().feedback().labels()));
            try {
                Log.debugf("Sending report: %s", report);
                notifier.send(report);
                sent.add(report.serialized());
            } catch (IOException | RuntimeException e) {
                Log.errorf(e, "Failed to send lottery report with content %s", report);
            }
        }
        return sent;
    }

}
